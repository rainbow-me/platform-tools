package gateway

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"

	internalmetadata "github.com/rainbow-me/platfomt-tools/grpc/metadata"
)

const (
	// DefaultServerAddress is the standard gRPC server address that a REST
	// gateway will connect to.
	DefaultServerAddress = ":9090"
	// DefaultTimeout for gRPC dial
	DefaultTimeout = 30 * time.Second
)

// Option is a functional option that modifies the REST gateway on initialization
type Option func(*gateway)

type registerFunc func(context.Context, *runtime.ServeMux, string, []grpc.DialOption) error

// WithDialOptions assigns a list of gRPC dial options to the REST gateway
func WithDialOptions(options ...grpc.DialOption) Option {
	return func(g *gateway) {
		g.serverDialOptions = options
	}
}

// WithEndpointRegistration takes a group of HTTP handlers that have been
// generated by the gRPC gateway protoc plugin and registers them to the REST
// gateway with some prefix (e.g. www.website.com/prefix/endpoint)
func WithEndpointRegistration(prefix string, endpoints ...registerFunc) Option {
	return func(g *gateway) {
		g.endpoints[prefix] = append(g.endpoints[prefix], endpoints...)
	}
}

// WithServerAddress determines what address the gateway will connect to. By
// default, the gateway will connect to 0.0.0.0:9090
func WithServerAddress(address string) Option {
	return func(g *gateway) {
		g.serverAddress = address
	}
}

// WithMux will use the given http.ServeMux to register the gateway endpoints.
func WithMux(mux *http.ServeMux) Option {
	return func(g *gateway) {
		g.mux = mux
	}
}

// WithGatewayOptions allows for additional gateway ServeMuxOptions beyond the
// default ProtoMessageErrorHandler and MetadataAnnotator from this package
func WithGatewayOptions(opt ...runtime.ServeMuxOption) Option {
	return func(g *gateway) {
		g.gatewayMuxOptions = append(g.gatewayMuxOptions, opt...)
	}
}

// WithHeaderConfig configures which headers to extract and forward
func WithHeaderConfig(config internalmetadata.HeaderConfig) Option {
	return func(g *gateway) {
		g.headerConfig = config
	}
}

// WithLogger sets a custom logger
func WithLogger(logger *slog.Logger) Option {
	return func(g *gateway) {
		g.logger = logger
	}
}

// WithTimeout sets the dial timeout
func WithTimeout(timeout time.Duration) Option {
	return func(g *gateway) {
		g.timeout = timeout
	}
}

// WithTLS enables TLS for gRPC connections
func WithTLS(creds grpc.DialOption) Option {
	return func(g *gateway) {
		// Remove insecure credentials and add TLS
		g.serverDialOptions = []grpc.DialOption{creds}
	}
}

// WithHeadersToForward specifies which headers to forward to gRPC
func WithHeadersToForward(headers ...string) Option {
	return func(g *gateway) {
		g.headerConfig.HeadersToForward = headers
	}
}

type gateway struct {
	serverAddress     string
	serverDialOptions []grpc.DialOption
	endpoints         map[string][]registerFunc
	mux               *http.ServeMux
	gatewayMuxOptions []runtime.ServeMuxOption
	headerConfig      internalmetadata.HeaderConfig
	logger            *slog.Logger
	timeout           time.Duration
}

// NewGateway creates a gRPC REST gateway with HTTP handlers that have been
// generated by the gRPC gateway protoc plugin
func NewGateway(options ...Option) (*http.ServeMux, error) {
	// configure gateway defaults
	g := gateway{
		serverAddress: DefaultServerAddress,
		endpoints:     make(map[string][]registerFunc),
		serverDialOptions: []grpc.DialOption{
			grpc.WithTransportCredentials(insecure.NewCredentials()),
		},
		mux:     http.NewServeMux(),
		timeout: DefaultTimeout,
		headerConfig: internalmetadata.HeaderConfig{
			HeadersToForward: internalmetadata.GetHeadersToForward(),
		},
		logger: slog.Default(),
	}

	// apply functional options
	for _, opt := range options {
		opt(&g)
	}

	return g.registerEndpoints()
}

// registerEndpoints iterates through each prefix and registers its handlers
// to the REST gateway
func (g gateway) registerEndpoints() (*http.ServeMux, error) {
	if len(g.endpoints) == 0 {
		return nil, ErrNoEndpointsRegistered
	}

	for prefix, registers := range g.endpoints {
		if err := g.validatePrefix(prefix); err != nil {
			return nil, fmt.Errorf("invalid prefix %s: %w", prefix, err)
		}

		gwmux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.protoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.headerMatcher),
				runtime.WithMetadata(g.metadataAnnotator),
				runtime.WithForwardResponseOption(g.responseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.outgoingHeaderMatcher),
			}, g.gatewayMuxOptions...)...,
		)

		for _, register := range registers {
			if err := register(context.Background(), gwmux, g.serverAddress, g.serverDialOptions); err != nil {
				g.logger.Error("Failed to register endpoint", "prefix", prefix, "error", err)

				return nil, fmt.Errorf("failed to register endpoint for prefix %s: %w", prefix, err)
			}
		}

		// strip prefix from request URI, but leave the trailing "/"
		handler := http.StripPrefix(prefix[:len(prefix)-1], gwmux)

		// Add middleware for logging and validation
		g.mux.Handle(prefix, g.loggingMiddleware(handler))

		g.logger.Info("Registered endpoint", "prefix", prefix)
	}

	return g.mux, nil
}

// metadataAnnotator extracts HTTP headers and converts them to gRPC metadata
func (g gateway) metadataAnnotator(ctx context.Context, r *http.Request) metadata.MD {
	md := metadata.MD{}

	// Extract and forward configured headers
	for _, headerName := range g.headerConfig.HeadersToForward {
		if value := r.Header.Get(headerName); value != "" {
			md[strings.ToLower(headerName)] = []string{value}
			g.logger.DebugContext(ctx, "Forwarding header to gRPC", "header", headerName, "value", value)
		}
	}

	return md
}

// headerMatcher determines which incoming headers to include
func (g gateway) headerMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Check if this header should be forwarded
	for _, header := range g.headerConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return key, true
		}
	}

	return "", false
}

// outgoingHeaderMatcher determines which outgoing headers to include in HTTP response
func (g gateway) outgoingHeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Forward the same headers we accept for requests
	for _, header := range g.headerConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return header, true
		}
	}

	// Allow standard response headers
	switch key {
	case "content-type", "content-length":
		return key, true
	default:
		return "", false
	}
}

// loggingMiddleware adds request logging
func (g gateway) loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		// Create a response writer wrapper to capture status code
		wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

		next.ServeHTTP(wrapped, r)

		duration := time.Since(start)

		g.logger.Info("HTTP request",
			"method", r.Method,
			"path", r.URL.Path,
			"status", wrapped.statusCode,
			"duration", duration,
			"user_agent", r.Header.Get("User-Agent"),
			"remote_addr", r.RemoteAddr,
		)
	})
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
	http.ResponseWriter
	statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

// protoMessageErrorHandler handles gRPC errors and converts them to appropriate HTTP responses
func (g gateway) protoMessageErrorHandler(
	ctx context.Context,
	mux *runtime.ServeMux,
	marshaller runtime.Marshaler,
	w http.ResponseWriter,
	r *http.Request,
	err error,
) {
	g.logger.ErrorContext(ctx, "gRPC error", "error", err, "path", r.URL.Path)
	runtime.DefaultHTTPErrorHandler(ctx, mux, marshaller, w, r, err)
}

// responseHeaderHandler processes gRPC response metadata and sets HTTP response headers
func (g gateway) responseHeaderHandler(ctx context.Context, w http.ResponseWriter, _ proto.Message) error {
	// Extract gRPC response metadata
	if md, ok := runtime.ServerMetadataFromContext(ctx); ok {
		// Process header metadata (sent during the call)
		for key, values := range md.HeaderMD {
			if g.shouldForwardResponseHeader(key) {
				for _, value := range values {
					w.Header().Set(key, value)
				}

				g.logger.DebugContext(ctx, "Added response header", "header", key, "values", values)
			}
		}

		// Process trailer metadata (sent at the end of the call)
		for key, values := range md.TrailerMD {
			if g.shouldForwardResponseHeader(key) {
				for _, value := range values {
					w.Header().Set(key, value)
				}
				g.logger.DebugContext(ctx, "Added response trailer as header", "header", key, "values", values)
			}
		}
	}

	return nil
}

// shouldForwardResponseHeader checks if a gRPC metadata key should be forwarded as HTTP header
func (g gateway) shouldForwardResponseHeader(grpcKey string) bool {
	grpcKey = strings.ToLower(grpcKey)

	// Forward the same headers we accept for requests
	for _, header := range g.headerConfig.HeadersToForward {
		if strings.ToLower(header) == grpcKey {
			return true
		}
	}

	return false
}

// validatePrefix validates the endpoint prefix
func (g gateway) validatePrefix(prefix string) error {
	if prefix == "" {
		return fmt.Errorf("%w: cannot be empty", ErrInvalidPrefix)
	}
	if !strings.HasSuffix(prefix, "/") {
		return fmt.Errorf("%w: must end with '/'", ErrInvalidPrefix)
	}
	if !strings.HasPrefix(prefix, "/") {
		return fmt.Errorf("%w: must start with '/'", ErrInvalidPrefix)
	}
	return nil
}
