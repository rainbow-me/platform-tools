package gateway

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"

	"github.com/rainbow-me/platform-tools/common/logger"
	internalmetadata "github.com/rainbow-me/platform-tools/grpc/metadata"
)

const (
	// DefaultServerAddress is the standard gRPC server address that a REST
	// Gateway will connect to.
	DefaultServerAddress = ":9090"
	// DefaultTimeout for gRPC dial
	DefaultTimeout = 30 * time.Second
)

// Option is a functional option that modifies the REST Gateway on initialization
type Option func(*Gateway)

type RegisterFunc func(context.Context, *runtime.ServeMux, string, []grpc.DialOption) error

// WithDialOptions assigns a list of gRPC dial options to the REST Gateway
func WithDialOptions(options ...grpc.DialOption) Option {
	return func(g *Gateway) {
		g.ServerDialOptions = options
	}
}

// WithEndpointRegistration takes a group of HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin and registers them to the REST
// Gateway with some prefix (e.g. www.website.com/prefix/endpoint)
func WithEndpointRegistration(prefix string, endpoints ...RegisterFunc) Option {
	return func(g *Gateway) {
		g.Endpoints[prefix] = append(g.Endpoints[prefix], endpoints...)
	}
}

// WithServerAddress determines what address the Gateway will connect to. By
// default, the Gateway will connect to 0.0.0.0:9090
func WithServerAddress(address string) Option {
	return func(g *Gateway) {
		g.ServerAddress = address
	}
}

// WithEngine will use the given gin.Engine to register the Gateway Endpoints.
func WithEngine(engine *gin.Engine) Option {
	return func(g *Gateway) {
		g.Engine = engine
	}
}

// WithGatewayOptions allows for additional Gateway ServeMuxOptions beyond the
// default ProtoMessageErrorHandler and MetadataAnnotator from this package
func WithGatewayOptions(opt ...runtime.ServeMuxOption) Option {
	return func(g *Gateway) {
		g.GatewayMuxOptions = append(g.GatewayMuxOptions, opt...)
	}
}

// WithLogger sets a custom Logger
func WithLogger(logger *logger.Logger) Option {
	return func(g *Gateway) {
		g.Logger = logger
	}
}

// WithTimeout sets the dial Timeout
func WithTimeout(timeout time.Duration) Option {
	return func(g *Gateway) {
		g.Timeout = timeout
	}
}

// WithTLS enables TLS for gRPC connections
func WithTLS(creds grpc.DialOption) Option {
	return func(g *Gateway) {
		// Remove insecure credentials and add TLS
		g.ServerDialOptions = []grpc.DialOption{creds}
	}
}

// WithHeadersToForward specifies which headers to forward to gRPC
func WithHeadersToForward(headers ...string) Option {
	return func(g *Gateway) {
		g.HeaderConfig.HeadersToForward = headers
	}
}

// WithHealthCheck enables the /health endpoint using the provided gRPC health server.
func WithHealthCheck(healthServer *health.Server, endpoint string) Option {
	return func(g *Gateway) {
		g.HealthServer = healthServer
		g.HealthEndpoint = endpoint
	}
}

// WithGinMiddlewares adds custom Gin middleware functions to apply to the gateway endpoint groups.
// Middlewares are applied in the order provided.
func WithGinMiddlewares(mws ...gin.HandlerFunc) Option {
	return func(g *Gateway) {
		g.GinMiddlewares = append(g.GinMiddlewares, mws...)
	}
}

// WithHTTPHandlers adds custom functions to register additional HTTP handlers/routes on the Gin engine.
// These are called after registering the gateway endpoints and health check, allowing extension of the server.
func WithHTTPHandlers(registrars ...func(*gin.Engine)) Option {
	return func(g *Gateway) {
		g.CustomRegistrars = append(g.CustomRegistrars, registrars...)
	}
}

type Gateway struct {
	ServerAddress     string
	ServerDialOptions []grpc.DialOption
	Endpoints         map[string][]RegisterFunc
	Engine            *gin.Engine
	GatewayMuxOptions []runtime.ServeMuxOption
	HeaderConfig      internalmetadata.HeaderConfig
	Logger            *logger.Logger
	Timeout           time.Duration
	HealthServer      *health.Server
	HealthEndpoint    string
	GinMiddlewares    []gin.HandlerFunc
	CustomRegistrars  []func(*gin.Engine)
}

// NewGateway creates a gRPC REST Gateway with HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin
func NewGateway(options ...Option) (*gin.Engine, error) {
	// configure Gateway defaults
	g := &Gateway{
		ServerAddress: DefaultServerAddress,
		Endpoints:     make(map[string][]RegisterFunc),
		ServerDialOptions: []grpc.DialOption{
			grpc.WithTransportCredentials(insecure.NewCredentials()),
		},
		Engine:  gin.New(),
		Timeout: DefaultTimeout,
		HeaderConfig: internalmetadata.HeaderConfig{
			HeadersToForward: internalmetadata.GetHeadersToForward(),
		},
		Logger:           logger.NoOp(),
		GinMiddlewares:   []gin.HandlerFunc{},
		CustomRegistrars: []func(*gin.Engine){},
	}

	// apply functional options
	for _, opt := range options {
		opt(g)
	}

	return g.RegisterEndpoints()
}

// RegisterEndpoints iterates through each prefix and registers its handlers
// to the REST Gateway
func (g *Gateway) RegisterEndpoints() (*gin.Engine, error) {
	if len(g.Endpoints) == 0 {
		return nil, ErrNoEndpointsRegistered
	}

	// Validate all prefixes first
	var validationErrs []error
	for prefix := range g.Endpoints {
		if err := g.ValidatePrefix(prefix); err != nil {
			validationErrs = append(validationErrs, fmt.Errorf("invalid prefix %s: %w", prefix, err))
		}
	}
	if len(validationErrs) > 0 {
		return nil, errors.Join(validationErrs...)
	}

	// Register Endpoints for each prefix
	for prefix, registers := range g.Endpoints {
		// Create the ServeMux with options
		gwMux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.ProtoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.HeaderMatcher),
				runtime.WithMetadata(g.MetadataAnnotator),
				runtime.WithForwardResponseOption(g.ResponseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.OutgoingHeaderMatcher),
			}, g.GatewayMuxOptions...)...,
		)

		// Register each endpoint handler
		for _, register := range registers {
			if err := register(context.Background(), gwMux, g.ServerAddress, g.ServerDialOptions); err != nil {
				return nil, fmt.Errorf("failed to register endpoint for prefix %s: %w", prefix, err)
			}
		}

		// Create a Gin group for the prefix (without trailing slash)
		prefixGroup := g.Engine.Group(strings.TrimSuffix(prefix, "/"))

		// Apply custom Gin middlewares to this group
		prefixGroup.Use(g.GinMiddlewares...)

		// Calculate the strip prefix (without trailing slash)
		stripPrefix := prefix[:len(prefix)-1]

		// Register the catch-all handler with stripping
		prefixGroup.Any("/*path", g.stripPrefixHandler(stripPrefix, gwMux))
	}

	// Register health check if enabled
	if g.HealthServer != nil && g.HealthEndpoint != "" {
		g.Engine.GET(g.HealthEndpoint, g.HealthHandler())
		g.Logger.Info("Registered health check endpoint", zap.String("path", g.HealthEndpoint))
	}

	// Register custom HTTP handlers
	for _, registrar := range g.CustomRegistrars {
		registrar(g.Engine)
	}

	return g.Engine, nil
}

// HealthHandler returns a Gin handler for health checks
func (g *Gateway) HealthHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		service := c.Query("service")

		resp, err := g.HealthServer.Check(c.Request.Context(), &grpc_health_v1.HealthCheckRequest{
			Service: service,
		})
		if err != nil {
			g.Logger.Error("Health check failed", zap.Error(err), zap.String("service", service))
			c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{"error": err.Error()})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"status": resp.GetStatus().String(),
		})
	}
}

// stripPrefixHandler creates a Gin handler that strips the prefix
// from the path before delegating to the given http.Handler
func (g *Gateway) stripPrefixHandler(strip string, h http.Handler) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Strip the prefix from the path
		c.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, strip)
		if c.Request.URL.RawPath != "" {
			c.Request.URL.RawPath = strings.TrimPrefix(c.Request.URL.RawPath, strip)
		}

		// Delegate to the handler
		h.ServeHTTP(c.Writer, c.Request)
	}
}

// MetadataAnnotator extracts HTTP headers and converts them to gRPC metadata
func (g *Gateway) MetadataAnnotator(_ context.Context, r *http.Request) metadata.MD {
	md := metadata.MD{}

	// Extract and forward configured headers
	for _, headerName := range g.HeaderConfig.HeadersToForward {
		if value := r.Header.Get(headerName); value != "" {
			md[strings.ToLower(headerName)] = []string{value}
		}
	}

	return md
}

// HeaderMatcher determines which incoming headers to include
func (g *Gateway) HeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Check if this header should be forwarded
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return key, true
		}
	}

	return "", false
}

// OutgoingHeaderMatcher determines which outgoing headers to include in HTTP response
func (g *Gateway) OutgoingHeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return header, true
		}
	}

	// Allow standard response headers
	switch key {
	case "content-type", "content-length":
		return key, true
	default:
		return "", false
	}
}

// ProtoMessageErrorHandler handles gRPC errors and converts them to appropriate HTTP responses
func (g *Gateway) ProtoMessageErrorHandler(
	ctx context.Context,
	mux *runtime.ServeMux,
	marshaller runtime.Marshaler,
	w http.ResponseWriter,
	r *http.Request,
	err error,
) {
	g.Logger.Error("gRPC error",
		zap.Error(err),
		zap.String("path", r.URL.Path),
	)
	runtime.DefaultHTTPErrorHandler(ctx, mux, marshaller, w, r, err)
}

// ResponseHeaderHandler processes gRPC response metadata and sets HTTP response headers
func (g *Gateway) ResponseHeaderHandler(ctx context.Context, w http.ResponseWriter, _ proto.Message) error {
	// Extract gRPC response metadata
	if md, ok := runtime.ServerMetadataFromContext(ctx); ok {
		// Process header metadata (sent during the call)
		for key, values := range md.HeaderMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}

		// Process trailer metadata (sent at the end of the call)
		for key, values := range md.TrailerMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}
	}

	return nil
}

// ShouldForwardResponseHeader checks if a gRPC metadata key should be forwarded as HTTP header
func (g *Gateway) ShouldForwardResponseHeader(grpcKey string) bool {
	grpcKey = strings.ToLower(grpcKey)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == grpcKey {
			return true
		}
	}

	return false
}

// ValidatePrefix validates the endpoint prefix
func (g *Gateway) ValidatePrefix(prefix string) error {
	if prefix == "" {
		return fmt.Errorf("%w: cannot be empty", ErrInvalidPrefix)
	}
	if !strings.HasSuffix(prefix, "/") {
		return fmt.Errorf("%w: must end with '/'", ErrInvalidPrefix)
	}
	if !strings.HasPrefix(prefix, "/") {
		return fmt.Errorf("%w: must start with '/'", ErrInvalidPrefix)
	}
	return nil
}

/*import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"

	"github.com/rainbow-me/platform-tools/common/logger"
	internalmetadata "github.com/rainbow-me/platform-tools/grpc/metadata"
)

const (
	// DefaultServerAddress is the standard gRPC server address that a REST
	// Gateway will connect to.
	DefaultServerAddress = ":9090"
	// DefaultTimeout for gRPC dial
	DefaultTimeout = 30 * time.Second
)

// Option is a functional option that modifies the REST Gateway on initialization
type Option func(*Gateway)

type RegisterFunc func(context.Context, *runtime.ServeMux, string, []grpc.DialOption) error

// WithDialOptions assigns a list of gRPC dial options to the REST Gateway
func WithDialOptions(options ...grpc.DialOption) Option {
	return func(g *Gateway) {
		g.ServerDialOptions = options
	}
}

// WithEndpointRegistration takes a group of HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin and registers them to the REST
// Gateway with some prefix (e.g. www.website.com/prefix/endpoint)
func WithEndpointRegistration(prefix string, endpoints ...RegisterFunc) Option {
	return func(g *Gateway) {
		g.Endpoints[prefix] = append(g.Endpoints[prefix], endpoints...)
	}
}

// WithServerAddress determines what address the Gateway will connect to. By
// default, the Gateway will connect to 0.0.0.0:9090
func WithServerAddress(address string) Option {
	return func(g *Gateway) {
		g.ServerAddress = address
	}
}

// WithEngine will use the given gin.Engine to register the Gateway Endpoints.
func WithEngine(engine *gin.Engine) Option {
	return func(g *Gateway) {
		g.Engine = engine
	}
}

// WithGatewayOptions allows for additional Gateway ServeMuxOptions beyond the
// default ProtoMessageErrorHandler and MetadataAnnotator from this package
func WithGatewayOptions(opt ...runtime.ServeMuxOption) Option {
	return func(g *Gateway) {
		g.GatewayMuxOptions = append(g.GatewayMuxOptions, opt...)
	}
}

// WithLogger sets a custom Logger
func WithLogger(logger *logger.Logger) Option {
	return func(g *Gateway) {
		g.Logger = logger
	}
}

// WithTimeout sets the dial Timeout
func WithTimeout(timeout time.Duration) Option {
	return func(g *Gateway) {
		g.Timeout = timeout
	}
}

// WithTLS enables TLS for gRPC connections
func WithTLS(creds grpc.DialOption) Option {
	return func(g *Gateway) {
		// Remove insecure credentials and add TLS
		g.ServerDialOptions = []grpc.DialOption{creds}
	}
}

// WithHeadersToForward specifies which headers to forward to gRPC
func WithHeadersToForward(headers ...string) Option {
	return func(g *Gateway) {
		g.HeaderConfig.HeadersToForward = headers
	}
}

// WithRequestLogging enables logging of HTTP requests to Endpoints. For development only.
func WithRequestLogging() Option {
	return func(g *Gateway) {
		g.EnableRequestLogging = true
	}
}

// WithHealthCheck enables the /health endpoint using the provided gRPC health server.
func WithHealthCheck(healthServer *health.Server, endpoint string) Option {
	return func(g *Gateway) {
		g.HealthServer = healthServer
		g.HealthEndpoint = endpoint
	}
}

type Gateway struct {
	ServerAddress        string
	ServerDialOptions    []grpc.DialOption
	Endpoints            map[string][]RegisterFunc
	Engine               *gin.Engine
	GatewayMuxOptions    []runtime.ServeMuxOption
	HeaderConfig         internalmetadata.HeaderConfig
	Logger               *logger.Logger
	Timeout              time.Duration
	EnableRequestLogging bool
	HealthServer         *health.Server
	HealthEndpoint       string
}

// NewGateway creates a gRPC REST Gateway with HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin
func NewGateway(options ...Option) (*gin.Engine, error) {
	// configure Gateway defaults
	g := &Gateway{
		ServerAddress: DefaultServerAddress,
		Endpoints:     make(map[string][]RegisterFunc),
		ServerDialOptions: []grpc.DialOption{
			grpc.WithTransportCredentials(insecure.NewCredentials()),
		},
		Engine:  gin.New(),
		Timeout: DefaultTimeout,
		HeaderConfig: internalmetadata.HeaderConfig{
			HeadersToForward: internalmetadata.GetHeadersToForward(),
		},
		Logger: logger.NoOp(),
	}

	// apply functional options
	for _, opt := range options {
		opt(g)
	}

	return g.RegisterEndpoints()
}

// RegisterEndpoints iterates through each prefix and registers its handlers
// to the REST Gateway
func (g *Gateway) RegisterEndpoints() (*gin.Engine, error) {
	if len(g.Endpoints) == 0 {
		return nil, ErrNoEndpointsRegistered
	}

	// Validate all prefixes first
	var validationErrs []error
	for prefix := range g.Endpoints {
		if err := g.ValidatePrefix(prefix); err != nil {
			validationErrs = append(validationErrs, fmt.Errorf("invalid prefix %s: %w", prefix, err))
		}
	}
	if len(validationErrs) > 0 {
		return nil, errors.Join(validationErrs...)
	}

	// Register Endpoints for each prefix
	for prefix, registers := range g.Endpoints {
		// Create the ServeMux with options
		gwMux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.ProtoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.HeaderMatcher),
				runtime.WithMetadata(g.MetadataAnnotator),
				runtime.WithForwardResponseOption(g.ResponseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.OutgoingHeaderMatcher),
			}, g.GatewayMuxOptions...)...,
		)

		// Register each endpoint handler
		for _, register := range registers {
			if err := register(context.Background(), gwMux, g.ServerAddress, g.ServerDialOptions); err != nil {
				return nil, fmt.Errorf("failed to register endpoint for prefix %s: %w", prefix, err)
			}
		}

		// Prepare the handler
		handler := gwMux

		// Calculate the strip prefix (without trailing slash)
		stripPrefix := prefix[:len(prefix)-1]

		// Register with Gin: Use Any with a named wildcard (*path) to handle all methods and paths under the prefix
		g.Engine.Any(prefix+"*path", g.stripPrefixHandler(stripPrefix, handler))

		// Log the registration
		g.Logger.Info("Registered endpoint",
			zap.String("prefix", prefix),
		)
	}

	// Register health check if enabled
	if g.HealthServer != nil && g.HealthEndpoint != "" {
		g.Engine.GET(g.HealthEndpoint, gin.WrapF(g.HealthHandler()))
		g.Logger.Info("Registered health check endpoint", zap.String("path", g.HealthEndpoint))
	}

	return g.Engine, nil
}

// HealthHandler returns an HTTP handler for health checks
func (g *Gateway) HealthHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		service := r.URL.Query().Get("service")

		resp, err := g.HealthServer.Check(r.Context(), &grpc_health_v1.HealthCheckRequest{
			Service: service,
		})
		if err != nil {
			g.Logger.Error("Health check failed", zap.Error(err), zap.String("service", service))
			http.Error(w, err.Error(), http.StatusServiceUnavailable)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err = json.NewEncoder(w).Encode(map[string]string{
			"status": resp.GetStatus().String(),
		}); err != nil {
			g.Logger.Error("Failed to encode health response", zap.Error(err))
		}
	}
}

// WrapHandler adds middleware for logging
func (g *Gateway) WrapHandler(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		defer func() {
			duration := time.Since(start)
			g.Logger.Info("Handled HTTP request",
				zap.String("method", r.Method),
				zap.String("path", r.URL.Path),
				zap.Duration("duration", duration),
				zap.String("remote_addr", r.RemoteAddr),
			)
		}()

		// Add validation here if needed, e.g., rate limiting or auth

		handler.ServeHTTP(w, r)
	})
}

// stripPrefixHandler creates a Gin handler that strips the prefix from the path
// before delegating to the given http.Handler
func (g *Gateway) stripPrefixHandler(strip string, h http.Handler) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Strip the prefix from the path
		c.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, strip)
		if c.Request.URL.RawPath != "" {
			c.Request.URL.RawPath = strings.TrimPrefix(c.Request.URL.RawPath, strip)
		}

		// Delegate to the handler
		h.ServeHTTP(c.Writer, c.Request)
	}
}

// MetadataAnnotator extracts HTTP headers and converts them to gRPC metadata
func (g *Gateway) MetadataAnnotator(_ context.Context, r *http.Request) metadata.MD {
	md := metadata.MD{}

	// Extract and forward configured headers
	for _, headerName := range g.HeaderConfig.HeadersToForward {
		if value := r.Header.Get(headerName); value != "" {
			md[strings.ToLower(headerName)] = []string{value}
		}
	}

	return md
}

// HeaderMatcher determines which incoming headers to include
func (g *Gateway) HeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Check if this header should be forwarded
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return key, true
		}
	}

	return "", false
}

// OutgoingHeaderMatcher determines which outgoing headers to include in HTTP response
func (g *Gateway) OutgoingHeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return header, true
		}
	}

	// Allow standard response headers
	switch key {
	case "content-type", "content-length":
		return key, true
	default:
		return "", false
	}
}

// ProtoMessageErrorHandler handles gRPC errors and converts them to appropriate HTTP responses
func (g *Gateway) ProtoMessageErrorHandler(
	ctx context.Context,
	mux *runtime.ServeMux,
	marshaller runtime.Marshaler,
	w http.ResponseWriter,
	r *http.Request,
	err error,
) {
	g.Logger.Error("gRPC error",
		zap.Error(err),
		zap.String("path", r.URL.Path),
	)
	runtime.DefaultHTTPErrorHandler(ctx, mux, marshaller, w, r, err)
}

// ResponseHeaderHandler processes gRPC response metadata and sets HTTP response headers
func (g *Gateway) ResponseHeaderHandler(ctx context.Context, w http.ResponseWriter, _ proto.Message) error {
	// Extract gRPC response metadata
	if md, ok := runtime.ServerMetadataFromContext(ctx); ok {
		// Process header metadata (sent during the call)
		for key, values := range md.HeaderMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}

		// Process trailer metadata (sent at the end of the call)
		for key, values := range md.TrailerMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}
	}

	return nil
}

// ShouldForwardResponseHeader checks if a gRPC metadata key should be forwarded as HTTP header
func (g *Gateway) ShouldForwardResponseHeader(grpcKey string) bool {
	grpcKey = strings.ToLower(grpcKey)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == grpcKey {
			return true
		}
	}

	return false
}

// ValidatePrefix validates the endpoint prefix
func (g *Gateway) ValidatePrefix(prefix string) error {
	if prefix == "" {
		return fmt.Errorf("%w: cannot be empty", ErrInvalidPrefix)
	}
	if !strings.HasSuffix(prefix, "/") {
		return fmt.Errorf("%w: must end with '/'", ErrInvalidPrefix)
	}
	if !strings.HasPrefix(prefix, "/") {
		return fmt.Errorf("%w: must start with '/'", ErrInvalidPrefix)
	}
	return nil
}
*/
/*package gateway

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"

	"github.com/rainbow-me/platform-tools/common/logger"
	internalmetadata "github.com/rainbow-me/platform-tools/grpc/metadata"
)

const (
	// DefaultServerAddress is the standard gRPC server address that a REST
	// Gateway will connect to.
	DefaultServerAddress = ":9090"
	// DefaultTimeout for gRPC dial
	DefaultTimeout = 30 * time.Second
)

// Option is a functional option that modifies the REST Gateway on initialization
type Option func(*Gateway)

type RegisterFunc func(context.Context, *runtime.ServeMux, string, []grpc.DialOption) error

// WithDialOptions assigns a list of gRPC dial options to the REST Gateway
func WithDialOptions(options ...grpc.DialOption) Option {
	return func(g *Gateway) {
		g.ServerDialOptions = options
	}
}

// WithEndpointRegistration takes a group of HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin and registers them to the REST
// Gateway with some prefix (e.g. www.website.com/prefix/endpoint)
func WithEndpointRegistration(prefix string, endpoints ...RegisterFunc) Option {
	return func(g *Gateway) {
		g.Endpoints[prefix] = append(g.Endpoints[prefix], endpoints...)
	}
}

// WithServerAddress determines what address the Gateway will connect to. By
// default, the Gateway will connect to 0.0.0.0:9090
func WithServerAddress(address string) Option {
	return func(g *Gateway) {
		g.ServerAddress = address
	}
}

// WithMux will use the given http.ServeMux to register the Gateway Endpoints.
func WithMux(mux *http.ServeMux) Option {
	return func(g *Gateway) {
		g.Mux = mux
	}
}

// WithGatewayOptions allows for additional Gateway ServeMuxOptions beyond the
// default ProtoMessageErrorHandler and MetadataAnnotator from this package
func WithGatewayOptions(opt ...runtime.ServeMuxOption) Option {
	return func(g *Gateway) {
		g.GatewayMuxOptions = append(g.GatewayMuxOptions, opt...)
	}
}

// WithLogger sets a custom Logger
func WithLogger(logger *logger.Logger) Option {
	return func(g *Gateway) {
		g.Logger = logger
	}
}

// WithTimeout sets the dial Timeout
func WithTimeout(timeout time.Duration) Option {
	return func(g *Gateway) {
		g.Timeout = timeout
	}
}

// WithTLS enables TLS for gRPC connections
func WithTLS(creds grpc.DialOption) Option {
	return func(g *Gateway) {
		// Remove insecure credentials and add TLS
		g.ServerDialOptions = []grpc.DialOption{creds}
	}
}

// WithHeadersToForward specifies which headers to forward to gRPC
func WithHeadersToForward(headers ...string) Option {
	return func(g *Gateway) {
		g.HeaderConfig.HeadersToForward = headers
	}
}

// WithRequestLogging enables logging of HTTP requests to Endpoints. For development only.
func WithRequestLogging() Option {
	return func(g *Gateway) {
		g.EnableRequestLogging = true
	}
}

// WithHealthCheck enables the /health endpoint using the provided gRPC health server.
func WithHealthCheck(healthServer *health.Server, endpoint string) Option {
	return func(g *Gateway) {
		g.HealthServer = healthServer
		g.HealthEndpoint = endpoint
	}
}

type Gateway struct {
	ServerAddress        string
	ServerDialOptions    []grpc.DialOption
	Endpoints            map[string][]RegisterFunc
	Mux                  *http.ServeMux
	GatewayMuxOptions    []runtime.ServeMuxOption
	HeaderConfig         internalmetadata.HeaderConfig
	Logger               *logger.Logger
	Timeout              time.Duration
	EnableRequestLogging bool
	HealthServer         *health.Server
	HealthEndpoint       string
}

// NewGateway creates a gRPC REST Gateway with HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin
func NewGateway(options ...Option) (*http.ServeMux, error) {
	// configure Gateway defaults
	g := &Gateway{
		ServerAddress: DefaultServerAddress,
		Endpoints:     make(map[string][]RegisterFunc),
		ServerDialOptions: []grpc.DialOption{
			grpc.WithTransportCredentials(insecure.NewCredentials()),
		},
		Mux:     http.NewServeMux(),
		Timeout: DefaultTimeout,
		HeaderConfig: internalmetadata.HeaderConfig{
			HeadersToForward: internalmetadata.GetHeadersToForward(),
		},
		// TODO why is this a noop?
		Logger: logger.NoOp(),
	}

	// apply functional options
	for _, opt := range options {
		opt(g)
	}

	return g.RegisterEndpoints()
}

// RegisterEndpoints iterates through each prefix and registers its handlers
// to the REST Gateway
func (g *Gateway) RegisterEndpoints() (*http.ServeMux, error) {
	if len(g.Endpoints) == 0 {
		return nil, ErrNoEndpointsRegistered
	}

	// Validate all prefixes first
	var validationErrs []error
	for prefix := range g.Endpoints {
		if err := g.ValidatePrefix(prefix); err != nil {
			validationErrs = append(validationErrs, fmt.Errorf("invalid prefix %s: %w", prefix, err))
		}
	}
	if len(validationErrs) > 0 {
		return nil, errors.Join(validationErrs...)
	}

	// Register Endpoints for each prefix
	for prefix, registers := range g.Endpoints {
		// Create the ServeMux with options
		gwMux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.ProtoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.HeaderMatcher),
				runtime.WithMetadata(g.MetadataAnnotator),
				runtime.WithForwardResponseOption(g.ResponseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.OutgoingHeaderMatcher),
			}, g.GatewayMuxOptions...)...,
		)

		// Register each endpoint handler
		for _, register := range registers {
			if err := register(context.Background(), gwMux, g.ServerAddress, g.ServerDialOptions); err != nil {
				return nil, fmt.Errorf("failed to register endpoint for prefix %s: %w", prefix, err)
			}
		}

		// Prepare the handler with prefix stripping
		handler := http.StripPrefix(prefix[:len(prefix)-1], gwMux)

		// Apply middleware if enabled
		finalHandler := handler
		if g.EnableRequestLogging {
			finalHandler = g.WrapHandler(handler)
		}

		// Register the handler to the Mux
		g.Mux.Handle(prefix, finalHandler)

		// Log the registration
		g.Logger.Info("Registered endpoint",
			zap.String("prefix", prefix),
		)
	}

	// Register health check if enabled
	if g.HealthServer != nil && g.HealthEndpoint != "" {
		g.Mux.HandleFunc(g.HealthEndpoint, g.HealthHandler())
		g.Logger.Info("Registered health check endpoint", zap.String("path", g.HealthEndpoint))
	}

	return g.Mux, nil
}

// HealthHandler returns an HTTP handler for health checks
func (g *Gateway) HealthHandler() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		service := r.URL.Query().Get("service")

		resp, err := g.HealthServer.Check(r.Context(), &grpc_health_v1.HealthCheckRequest{
			Service: service,
		})
		if err != nil {
			g.Logger.Error("Health check failed", zap.Error(err), zap.String("service", service))
			http.Error(w, err.Error(), http.StatusServiceUnavailable)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err = json.NewEncoder(w).Encode(map[string]string{
			"status": resp.GetStatus().String(),
		}); err != nil {
			g.Logger.Error("Failed to encode health response", zap.Error(err))
		}
	}
}

// WrapHandler adds middleware for logging
func (g *Gateway) WrapHandler(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		defer func() {
			duration := time.Since(start)
			g.Logger.Info("Handled HTTP request",
				zap.String("method", r.Method),
				zap.String("path", r.URL.Path),
				zap.Duration("duration", duration),
				zap.String("remote_addr", r.RemoteAddr),
			)
		}()

		// Add validation here if needed, e.g., rate limiting or auth

		handler.ServeHTTP(w, r)
	})
}

// MetadataAnnotator extracts HTTP headers and converts them to gRPC metadata
func (g *Gateway) MetadataAnnotator(_ context.Context, r *http.Request) metadata.MD {
	md := metadata.MD{}

	// Extract and forward configured headers
	for _, headerName := range g.HeaderConfig.HeadersToForward {
		if value := r.Header.Get(headerName); value != "" {
			md[strings.ToLower(headerName)] = []string{value}
		}
	}

	return md
}

// HeaderMatcher determines which incoming headers to include
func (g *Gateway) HeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Check if this header should be forwarded
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return key, true
		}
	}

	return "", false
}

// OutgoingHeaderMatcher determines which outgoing headers to include in HTTP response
func (g *Gateway) OutgoingHeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return header, true
		}
	}

	// Allow standard response headers
	switch key {
	case "content-type", "content-length":
		return key, true
	default:
		return "", false
	}
}

// ProtoMessageErrorHandler handles gRPC errors and converts them to appropriate HTTP responses
func (g *Gateway) ProtoMessageErrorHandler(
	ctx context.Context,
	mux *runtime.ServeMux,
	marshaller runtime.Marshaler,
	w http.ResponseWriter,
	r *http.Request,
	err error,
) {
	g.Logger.Error("gRPC error",
		zap.Error(err),
		zap.String("path", r.URL.Path),
	)
	runtime.DefaultHTTPErrorHandler(ctx, mux, marshaller, w, r, err)
}

// ResponseHeaderHandler processes gRPC response metadata and sets HTTP response headers
func (g *Gateway) ResponseHeaderHandler(ctx context.Context, w http.ResponseWriter, _ proto.Message) error {
	// Extract gRPC response metadata
	if md, ok := runtime.ServerMetadataFromContext(ctx); ok {
		// Process header metadata (sent during the call)
		for key, values := range md.HeaderMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}

		// Process trailer metadata (sent at the end of the call)
		for key, values := range md.TrailerMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}
	}

	return nil
}

// ShouldForwardResponseHeader checks if a gRPC metadata key should be forwarded as HTTP header
func (g *Gateway) ShouldForwardResponseHeader(grpcKey string) bool {
	grpcKey = strings.ToLower(grpcKey)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == grpcKey {
			return true
		}
	}

	return false
}

// ValidatePrefix validates the endpoint prefix
func (g *Gateway) ValidatePrefix(prefix string) error {
	if prefix == "" {
		return fmt.Errorf("%w: cannot be empty", ErrInvalidPrefix)
	}
	if !strings.HasSuffix(prefix, "/") {
		return fmt.Errorf("%w: must end with '/'", ErrInvalidPrefix)
	}
	if !strings.HasPrefix(prefix, "/") {
		return fmt.Errorf("%w: must start with '/'", ErrInvalidPrefix)
	}
	return nil
}
*/
