package gateway

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/proto"

	"github.com/rainbow-me/platform-tools/common/logger"
	internalmetadata "github.com/rainbow-me/platform-tools/grpc/metadata"
)

const (
	// DefaultServerAddress is the standard gRPC server address that a REST
	// Gateway will connect to.
	DefaultServerAddress = ":9090"
	// DefaultTimeout for gRPC dial
	DefaultTimeout = 30 * time.Second
)

// Option is a functional option that modifies the REST Gateway on initialization
type Option func(*Gateway)

type RegisterFunc func(context.Context, *runtime.ServeMux, string, []grpc.DialOption) error

// WithDialOptions assigns a list of gRPC dial options to the REST Gateway
func WithDialOptions(options ...grpc.DialOption) Option {
	return func(g *Gateway) {
		g.ServerDialOptions = options
	}
}

// WithEndpointRegistration takes a group of HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin and registers them to the REST
// Gateway with some prefix (e.g. www.website.com/prefix/endpoint)
func WithEndpointRegistration(prefix string, endpoints ...RegisterFunc) Option {
	return func(g *Gateway) {
		g.Endpoints[prefix] = append(g.Endpoints[prefix], endpoints...)
	}
}

// WithServerAddress determines what address the Gateway will connect to. By
// default, the Gateway will connect to 0.0.0.0:9090
func WithServerAddress(address string) Option {
	return func(g *Gateway) {
		g.ServerAddress = address
	}
}

// WithEngine will use the given gin.Engine to register the Gateway Endpoints.
func WithEngine(engine *gin.Engine) Option {
	return func(g *Gateway) {
		g.Engine = engine
	}
}

// WithGatewayOptions allows for additional Gateway ServeMuxOptions beyond the
// default ProtoMessageErrorHandler and MetadataAnnotator from this package
func WithGatewayOptions(opt ...runtime.ServeMuxOption) Option {
	return func(g *Gateway) {
		g.GatewayMuxOptions = append(g.GatewayMuxOptions, opt...)
	}
}

// WithLogger sets a custom Logger
func WithLogger(logger *logger.Logger) Option {
	return func(g *Gateway) {
		g.Logger = logger
	}
}

// WithTimeout sets the dial Timeout
func WithTimeout(timeout time.Duration) Option {
	return func(g *Gateway) {
		g.Timeout = timeout
	}
}

// WithTLS enables TLS for gRPC connections
func WithTLS(creds grpc.DialOption) Option {
	return func(g *Gateway) {
		// Remove insecure credentials and add TLS
		g.ServerDialOptions = []grpc.DialOption{creds}
	}
}

// WithHeadersToForward specifies which headers to forward to gRPC
func WithHeadersToForward(headers ...string) Option {
	return func(g *Gateway) {
		g.HeaderConfig.HeadersToForward = headers
	}
}

// WithHealthCheck enables the /health endpoint using the provided gRPC health server.
func WithHealthCheck(healthServer *health.Server, endpoint string) Option {
	return func(g *Gateway) {
		g.HealthServer = healthServer
		g.HealthEndpoint = endpoint
	}
}

// WithGinMiddlewares adds custom Gin middleware functions to apply to the gateway endpoint groups.
// Middlewares are applied in the order provided.
func WithGinMiddlewares(mws ...gin.HandlerFunc) Option {
	return func(g *Gateway) {
		g.GinMiddlewares = append(g.GinMiddlewares, mws...)
	}
}

// WithHTTPHandlers adds custom functions to register additional HTTP handlers/routes on the Gin engine.
// These are called after registering the gateway endpoints and health check, allowing extension of the server.
func WithHTTPHandlers(registrars ...func(*gin.Engine)) Option {
	return func(g *Gateway) {
		g.CustomRegistrars = append(g.CustomRegistrars, registrars...)
	}
}

type Gateway struct {
	ServerAddress     string
	ServerDialOptions []grpc.DialOption
	Endpoints         map[string][]RegisterFunc
	Engine            *gin.Engine
	GatewayMuxOptions []runtime.ServeMuxOption
	HeaderConfig      internalmetadata.HeaderConfig
	Logger            *logger.Logger
	Timeout           time.Duration
	HealthServer      *health.Server
	HealthEndpoint    string
	GinMiddlewares    []gin.HandlerFunc
	CustomRegistrars  []func(*gin.Engine)
}

// NewGateway creates a gRPC REST Gateway with HTTP handlers that have been
// generated by the gRPC Gateway protoc plugin
func NewGateway(options ...Option) (*gin.Engine, error) {
	// configure Gateway defaults
	g := &Gateway{
		ServerAddress: DefaultServerAddress,
		Endpoints:     make(map[string][]RegisterFunc),
		ServerDialOptions: []grpc.DialOption{
			grpc.WithTransportCredentials(insecure.NewCredentials()),
		},
		Engine:  gin.New(),
		Timeout: DefaultTimeout,
		HeaderConfig: internalmetadata.HeaderConfig{
			HeadersToForward: internalmetadata.GetHeadersToForward(),
		},
		Logger:           logger.NoOp(),
		GinMiddlewares:   []gin.HandlerFunc{},
		CustomRegistrars: []func(*gin.Engine){},
	}

	// apply functional options
	for _, opt := range options {
		opt(g)
	}

	return g.RegisterEndpoints()
}

// RegisterEndpoints iterates through each prefix and registers its handlers
// to the REST Gateway. This function is responsible for setting up the HTTP routing
// using Gin, including validation of prefixes, registration of health checks,
// custom handlers, and the gRPC-Gateway endpoints. It handles special cases like
// the root prefix ("/") to avoid routing conflicts with specific paths (e.g., health endpoint).
// The order of operations is crucial: health and custom handlers first for priority,
// then the root prefix using NoRoute for fallback handling, and finally non-root prefixes
// with groups for scoped routing. Middlewares (g.GinMiddlewares) are applied globally
// at the start, ensuring they cover all routes: health, custom handlers, root fallback,
// and non-root prefix groups.
func (g *Gateway) RegisterEndpoints() (*gin.Engine, error) {
	// Early exit if no endpoints are provided to register
	if len(g.Endpoints) == 0 {
		return nil, ErrNoEndpointsRegistered
	}

	// Validate all prefixes first to catch configuration errors early
	var validationErrs []error
	for prefix := range g.Endpoints {
		if err := g.ValidatePrefix(prefix); err != nil {
			validationErrs = append(validationErrs, fmt.Errorf("invalid prefix %s: %w", prefix, err))
		}
	}
	if len(validationErrs) > 0 {
		return nil, errors.Join(validationErrs...)
	}

	// Apply middlewares globally to all routes (health, custom, root, prefixes)
	g.Engine.Use(g.GinMiddlewares...)

	// Register health check if enabled. This is done first to ensure the specific
	// health path (e.g., "/_healthz") takes precedence over any wildcard routes.
	// Middlewares apply here due to global Use above.
	if g.HealthServer != nil && g.HealthEndpoint != "" {
		g.Engine.GET(g.HealthEndpoint, g.HealthHandler())
		g.Logger.Info("Registered health check endpoint", zap.String("path", g.HealthEndpoint))
	}

	// Register custom HTTP handlers provided via WithHttpHandlers. These are added
	// before gateway endpoints to allow users to override or add routes that might
	// conflict with or complement the gateway's paths. Middlewares apply to these.
	for _, registrar := range g.CustomRegistrars {
		registrar(g.Engine)
	}

	// Handle non-root prefixes after root: Loop through all prefixes except "/" and register
	// them using Gin Groups with wildcard catch-all routes. This supports multiple
	// prefixes like "/api/" or "/v1/", with global middlewares applied automatically.
	for prefix, registers := range g.Endpoints {
		if prefix == "/" {
			continue // Skip root; already handled above
		}

		// Create a new ServeMux for this prefix, configured with error handling,
		// header matching, metadata annotation, and other options.
		gwMux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.ProtoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.HeaderMatcher),
				runtime.WithMetadata(g.MetadataAnnotator),
				runtime.WithForwardResponseOption(g.ResponseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.OutgoingHeaderMatcher),
			}, g.GatewayMuxOptions...)...,
		)

		// Register the generated gRPC-Gateway handlers for this prefix.
		// These are typically functions like RegisterYourServiceHandlerFromEndpoint.
		for _, register := range registers {
			if err := register(context.Background(), gwMux, g.ServerAddress, g.ServerDialOptions); err != nil {
				return nil, fmt.Errorf("failed to register endpoint for prefix %s: %w", prefix, err)
			}
		}

		// Create a Gin router group for the prefix (trim trailing slash for Gin compatibility).
		prefixGroup := g.Engine.Group(strings.TrimSuffix(prefix, "/"))

		// Calculate the prefix to strip from incoming paths before proxying to gRPC.
		stripPrefix := prefix[:len(prefix)-1]

		// Register a catch-all wildcard route for all methods under the prefix,
		// using the StripPrefixHandler to adjust the path and delegate to the ServeMux.
		// Global middlewares apply here.
		prefixGroup.Any("/*path", g.StripPrefixHandler(stripPrefix, gwMux))

		// Log the successful registration for debugging and monitoring.
		g.Logger.Info("Registered endpoint", zap.String("prefix", prefix))
	}

	// Prioritize and handle root prefix ("/") first if present: Use Gin's NoRoute to set it as a fallback
	// handler. This avoids conflicts with specific routes (e.g., health) added earlier, as NoRoute
	// only catches unmatched paths. Global middlewares apply before the gateway handler.
	if registers, ok := g.Endpoints["/"]; ok {
		// Create a new ServeMux for the root prefix.
		gwMux := runtime.NewServeMux(
			append([]runtime.ServeMuxOption{
				runtime.WithErrorHandler(g.ProtoMessageErrorHandler),
				runtime.WithIncomingHeaderMatcher(g.HeaderMatcher),
				runtime.WithMetadata(g.MetadataAnnotator),
				runtime.WithForwardResponseOption(g.ResponseHeaderHandler),
				runtime.WithOutgoingHeaderMatcher(g.OutgoingHeaderMatcher),
			}, g.GatewayMuxOptions...)...,
		)

		// Register the generated handlers for the root prefix.
		for _, register := range registers {
			if err := register(context.Background(), gwMux, g.ServerAddress, g.ServerDialOptions); err != nil {
				return nil, fmt.Errorf("failed to register endpoint for prefix /: %w", err)
			}
		}

		// Wrap the ServeMux as a Gin handler func (no prefix stripping needed for root).
		gwHandler := gin.WrapH(gwMux)

		// Set as NoRoute (catches all unmatched paths; global middlewares already applied).
		g.Engine.NoRoute(gwHandler)

		// Log the successful registration.
		g.Logger.Info("Registered endpoint", zap.String("prefix", "/"))
	}

	// Return the fully configured Gin engine ready to serve.
	return g.Engine, nil
}

// HealthHandler returns a Gin handler for health checks
func (g *Gateway) HealthHandler() gin.HandlerFunc {
	return func(c *gin.Context) {
		service := c.Query("service")

		resp, err := g.HealthServer.Check(c.Request.Context(), &grpc_health_v1.HealthCheckRequest{
			Service: service,
		})
		if err != nil {
			g.Logger.Error("Health check failed", zap.Error(err), zap.String("service", service))
			c.AbortWithStatusJSON(http.StatusServiceUnavailable, gin.H{"error": err.Error()})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"status": resp.GetStatus().String(),
		})
	}
}

// StripPrefixHandler creates a Gin handler that strips the prefix
// from the path before delegating to the given http.Handler
func (g *Gateway) StripPrefixHandler(strip string, h http.Handler) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Strip the prefix from the path
		c.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, strip)
		if c.Request.URL.RawPath != "" {
			c.Request.URL.RawPath = strings.TrimPrefix(c.Request.URL.RawPath, strip)
		}

		// Delegate to the handler
		h.ServeHTTP(c.Writer, c.Request)
	}
}

// MetadataAnnotator extracts HTTP headers and converts them to gRPC metadata
func (g *Gateway) MetadataAnnotator(_ context.Context, r *http.Request) metadata.MD {
	md := metadata.MD{}

	// Extract and forward configured headers
	for _, headerName := range g.HeaderConfig.HeadersToForward {
		if value := r.Header.Get(headerName); value != "" {
			md[strings.ToLower(headerName)] = []string{value}
		}
	}

	return md
}

// HeaderMatcher determines which incoming headers to include
func (g *Gateway) HeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Check if this header should be forwarded
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return key, true
		}
	}

	return "", false
}

// OutgoingHeaderMatcher determines which outgoing headers to include in HTTP response
func (g *Gateway) OutgoingHeaderMatcher(key string) (string, bool) {
	key = strings.ToLower(key)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == key {
			return header, true
		}
	}

	// Allow standard response headers
	switch key {
	case "content-type", "content-length":
		return key, true
	default:
		return "", false
	}
}

// ProtoMessageErrorHandler handles gRPC errors and converts them to appropriate HTTP responses
func (g *Gateway) ProtoMessageErrorHandler(
	ctx context.Context,
	mux *runtime.ServeMux,
	marshaller runtime.Marshaler,
	w http.ResponseWriter,
	r *http.Request,
	err error,
) {
	g.Logger.Error("gRPC error",
		zap.Error(err),
		zap.String("path", r.URL.Path),
	)
	runtime.DefaultHTTPErrorHandler(ctx, mux, marshaller, w, r, err)
}

// ResponseHeaderHandler processes gRPC response metadata and sets HTTP response headers
func (g *Gateway) ResponseHeaderHandler(ctx context.Context, w http.ResponseWriter, _ proto.Message) error {
	// Extract gRPC response metadata
	if md, ok := runtime.ServerMetadataFromContext(ctx); ok {
		// Process header metadata (sent during the call)
		for key, values := range md.HeaderMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}

		// Process trailer metadata (sent at the end of the call)
		for key, values := range md.TrailerMD {
			if g.ShouldForwardResponseHeader(key) {
				properKey, _ := g.OutgoingHeaderMatcher(key)
				for _, value := range values {
					w.Header().Set(properKey, value)
				}
			}
		}
	}

	return nil
}

// ShouldForwardResponseHeader checks if a gRPC metadata key should be forwarded as HTTP header
func (g *Gateway) ShouldForwardResponseHeader(grpcKey string) bool {
	grpcKey = strings.ToLower(grpcKey)

	// Forward the same headers we accept for requests
	for _, header := range g.HeaderConfig.HeadersToForward {
		if strings.ToLower(header) == grpcKey {
			return true
		}
	}

	return false
}

// ValidatePrefix validates the endpoint prefix
func (g *Gateway) ValidatePrefix(prefix string) error {
	if prefix == "" {
		return fmt.Errorf("%w: cannot be empty", ErrInvalidPrefix)
	}
	if !strings.HasSuffix(prefix, "/") {
		return fmt.Errorf("%w: must end with '/'", ErrInvalidPrefix)
	}
	if !strings.HasPrefix(prefix, "/") {
		return fmt.Errorf("%w: must start with '/'", ErrInvalidPrefix)
	}
	return nil
}
